df <- df[sort(df$hasAutism)]
# Make a table of the most significant modules
df <- data.frame(modules$MEs[c("MEpurple", "MEtan", "MEdarkgreen", "MEblack", "MElightyellow", "MEcyan")], hasAutism)
df <- df[sort(rownames(df)),]
df
rownames(df) <- idx
df <- df[sort(rownames(df)),]
df
df <- df[sort(rownames(df)),]
df
df <- df[ rownames(df) , ]
df
df <- df[ rownames(df) , ]
df
sorted(df)
sort(df)
df.sort
arrange(df, order.rows = TRUE)
library(tidyverse)
rownames(df)
df[order(rownames(df)), ]
df <- data.frame(idx, modules$MEs[c("MEpurple", "MEtan", "MEdarkgreen", "MEblack", "MElightyellow", "MEcyan")], hasAutism)
# then we sort by idx column
df <- df[order(df$idx), ]
barplot(df$MEcyan)
df
barplot(df$MEcyan, col = hasAutism)
# then we sort by idx column
df <- df[order(df$idx, -df$hasAutism), ]
barplot(df$MEcyan, col = hasAutism)
# then we sort by idx column
df <- df[order(-df$hasAutism), ]
barplot(df$MEcyan, col = hasAutism)
df
df <- data.frame(idx, modules$MEs[c("MEpurple", "MEtan", "MEdarkgreen", "MEblack", "MElightyellow", "MEcyan")], hasAutism)
df
# then we sort by idx column
df <- df[order(df$idx, -df$hasAutism), ]
df
# then we sort by idx column
df <- df[order(-df$hasAutism), ]
df
# Make a table of the most significant modules with autism and index.
# we have to include indexing, rownames in df == rownames in bsd.cortex so idx is also likewise the same
# proof:
match(rownames(df), rownames(pData(bsd.cortex.norm)))
idx
# then we sort by idx column
df <- df[order(df$idx), ]
# Make a table of the most significant modules with autism and index.
# we have to include indexing, rownames in df == rownames in bsd.cortex so idx is also likewise the same
# proof:
match(rownames(df), rownames(pData(bsd.cortex.norm)))
idx
df <- data.frame(1:58, modules$MEs[c("MEpurple", "MEtan", "MEdarkgreen", "MEblack", "MElightyellow", "MEcyan")], hasAutism)
df
order(df$X1.58(idx))
barplot(df$MEcyan(idx), col = hasAutism)
df[idx]
df[idx, ]
barplot(df$MEcyan[idx], col = hasAutism)
barplot(df$MEcyan[idx], col = hasAutism[idx])
df <- data.frame(1:58, modules$MEs[c("MEpurple", "MEtan", "MEdarkgreen", "MEblack", "MElightyellow", "MEcyan")], hasAutism)
# then we sort by idx
barplot(df$MEcyan[idx], col = hasAutism[idx])
# then we sort by idx
barplot(df$MEcyan[idx], col = hasAutism[idx], legend.text = c("Autism", "Control"))
# then we sort by idx
barplot(df$MEcyan[idx], col = hasAutism[idx], legend = hasAutism[idx], legend.text = c("Autism", "Control"))
# then we sort by idx
barplot(df$MEcyan[idx], col = hasAutism[idx], legend = levels(hasAutism), legend.text = c("Autism", "Control"))
# then we sort by idx
barplot(df$MEcyan[idx], col = hasAutism[idx], legend = levels(df$hasAutism[idx]), legend.text = c("Autism", "Control"))
barplot(df$MEcyan[idx], col = hasAutism[idx])
legend = levels(df$hasAutism[idx]), legend.text = c("Autism", "Control")
# then we sort by idx
barplot(df$MEcyan[idx], col = c("Red", "Grey"))
barplot(df$MEcyan[idx], col = c("Red", "Grey"))
legend = levels(df$hasAutism[idx]), legend.text = c("Autism", "Control")
barplot(df$MEcyan[idx], col = c("Red", "Grey"), legend = levels(df$hasAutism[idx]), legend.text = c("Autism", "Control"))
# then we sort by idx
barplot(df$MEcyan[idx], col = df$hasAutism, legend = levels(df$hasAutism[idx]), legend.text = c("Autism", "Control"))
# then we sort by idx
barplot(df$MEcyan[idx], col = df$hasAutism[idx], legend = levels(df$hasAutism[idx]), legend.text = c("Autism", "Control"))
df <- data.frame(modules$MEs[c("MEpurple", "MEtan", "MEdarkgreen", "MEblack", "MElightyellow", "MEcyan")], hasAutism)
# then we sort by idx
barplot(df$MEcyan[idx], col = df$hasAutism[idx], legend = levels(df$hasAutism[idx]), legend.text = c("Autism", "Control"))
# then we sort by idx
barplot(df$MEcyan[idx], col = df$hasAutism[idx], legend = levels(df$hasAutism[idx]))
# then we sort by idx
barplot(df$MEcyan[idx], col = df$hasAutism[idx], legend = levels(df$hasAutism[idx]), col 1:2)
# then we sort by idx
barplot(df$MEcyan[idx], col = df$hasAutism[idx], legend = levels(df$hasAutism[idx]), col= 1:2)
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend = levels(df$hasAutism[idx]), col= 1:2
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend(legend = levels(df$hasAutism[idx]), col= 1:2)
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomleft", legend = levels(df$hasAutism[idx]), col= 1:2)
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomleft", legend = levels(hasAutism), col= 1:2)
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomleft", legend = levels(df$hasAutism[idx]), col= 1:2)
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomleft", legend = c("Autism", "Control"), col= 1:2)
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomright", legend = c("Autism", "Control"), col= 1:2)
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomright", legend = c("Autism", "Control")
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomright", legend = c("Autism", "Control"), col = levels(df$hasAutism[idx]))
?barplot
# then we sort by idx
barplot(df$MEcyan[idx], names.arg = df$hasAutism[idx])
data<-iris
plot(data$Sepal.Length, data$Sepal.Width, col=data$Species)
legend(7,4.3,unique(data$Species),col=1:length(data$Species),pch=1)
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomright", legend = c("Autism", "Control"), col = df$hasAutism[idx])
barplot(df$MEcyan[idx], col = df$hasAutism[idx])
legend("bottomright", legend = c("Autism", "Control"), col = df$hasAutism[idx])
library(ggplot2)
ggplot(df$MEcyan[idx], aes(x=df$hasAutism[idx], y=len, fill=df$hasAutism[idx])) +
geom_bar(stat="identity")
p<-ggplot(df, aes(x=dose, y=len, fill=dose)) +
geom_bar(stat="identity")+theme_minimal()
p
ggplot(df)
ggplot(data=df, aes(x=df$hasAutism[idx], y=df$MEcyan[idx], fill=supp))
ggplot(data=df, aes(x=df$hasAutism[idx], y=df$MEcyan[idx]))
ggplot(data=df, aes(x=hasAutism[idx], y=MEcyan[idx]))
barplot(df$MEcyan[idx], col = c("Red", "Grey")[df$hasAutism[idx]])
legend("bottomright", legend = c("Autism", "Control"), col = c("Red", "Grey")[df$hasAutism[idx]])
# then we sort by idx
barplot(df$MEcyan[idx], col = c("Red", "Grey")[df$hasAutism[idx]])
barplot(df$MEcyan[idx], col = c("Red", "Grey")[df$hasAutism[idx]])
# then we sort by idx
barplot(df$MEcyan[idx], col = c("Red", "Grey")[as.numeric(df$hasAutism[idx])])
plot(iris$Sepal.Length, iris$Sepal.Width, col=c('red', 'blue', 'green')[as.numeric(iris$Species)])
color[which(df$hasAutism=="TRUE")] = "red"
# then we sort by idx
barplot(df$MEcyan[idx], col = c("Red", "Grey")[df$hasAutism[idx]])
barplot(df$MEcyan[idx], col = c("red", "grey")[df$hasAutism[idx]])
# then we sort by idx
barplot(df$MEcyan[idx], col = c("red", "blue")[df$hasAutism[idx]])
colors = c("red", "blue")
# then we sort by idx
barplot(df$MEcyan[idx], col = colors[df$hasAutism[idx]])
# then we sort by idx
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), col = c("Red", "Grey")[df$hasAutism[idx]])
legend("bottomright", legend = c("Autism", "Control"), col = colors[as.factor(df$hasAutism[idx])])
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), col = colors[as.factor(df$hasAutism[idx])])
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), col = colors[as.factor(df$hasAutism[idx])], pch = 16)
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), pch = 16, col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = levels(df$hasAutism), pch = 16, col = colors[as.factor(df$hasAutism[idx])])
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = levels(df$hasAutism), pch = 16, col = colors[as.factor(df$hasAutism[idx])])
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), pch = colors, col = colors[as.factor(df$hasAutism[idx])])
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
as.factor(df$hasAutism[idx]
)
colors = c("grey", "red")
# then we sort by idx
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
# then we sort by idx
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])], legend= TRUE)
legend("bottomright", legend = c("Autism", "Control"), fill = colors)
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = colors)
# then we sort by idx
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
barplot(df$MEcyan[idx], col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
barplot(df$MEcyan[idx], title= "Model Eigengene" ,col = colors[as.factor(df$hasAutism[idx])])
?plot
barplot(df$MEcyan[idx], main= "Model Eigengene" ,col = colors[as.factor(df$hasAutism[idx])])
barplot(df$MEpurple[idx], main= "Model Eigengene Purple" ,col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
barplot(df$MEtan[idx], main= "Model Eigengene Tan" ,col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
barplot(df$MEdarkgreen[idx], main= "Model Eigengene Dark Green" ,col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
barplot(df$MElightyellow[idx], main= "Model Eigengene Light Yellow" ,col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
barplot(df$MEblack[idx], main= "Model Eigengene Black" ,col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
barplot(df$MEdarkgreen[idx], main= "Model Eigengene Dark Green" ,col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
barplot(df$MEtan[idx], main= "Model Eigengene Tan" ,col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
barplot(df$MEpurple[idx], main= "Model Eigengene Purple" ,col = colors[as.factor(df$hasAutism[idx])])
legend("bottomright", legend = c("Autism", "Control"), fill = c("Red", "Grey"))
# Measure module membership by calculating the correlation between genes and module eigengenes
kME <- cor(exp, modules$MEs)
kME <- as.data.frame(kME) # Convert to a data.frame
nrow(kME)
kME
Purple.central.genes <- data.frame(kME$MEpurple, fData(bsd.cortex.norm)$SYMBOl)
pData(bsd.cortex.norm)$symbol
rownames(pData(bsd.cortex.norm))
pData(bsd.cortex.norm)
fData(bsd.cortex.norm)$SYMBOL
Purple.central.genes <- data.frame(kME$MEpurple, fData(bsd.cortex.norm)$SYMBOl))
Purple.central.genes <- data.frame(kME$MEpurple, (fData(bsd.cortex.norm)$SYMBOl))
nrow(fData(bsd.cortex.norm)$SYMBOL)
fData(bsd.cortex.norm)$SYMBOL
symbols <- data.frame(fData(bsd.cortex.norm)$SYMBOL)
Purple.central.genes <- data.frame(kME$MEpurple, symbols)
Purple.genes <- data.frame(kME$MEpurple, symbols)
Purple.genes
# Sort by correlation
Purple.genes <- Purple.genes[order(Purple.genes$kME.MEpurple)]
# Sort by correlation
Purple.genes <- Purple.genes[order(Purple.genes$kME.MEpurple), ]
Purple.genes
# Sort by correlation
Purple.genes <- Purple.genes[order(kME.MEpurple), ]
# Sort by correlation
Purple.genes <- Purple.genes[order(Purple.genes$kME.MEpurple), ]
Purple.genes
# Sort by correlation
Purple.genes <- Purple.genes[order(Purple.genes$kME.MEpurple), ]
Purple.genes
# Sort by correlation
Purple.genes <- Purple.genes[order(-Purple.genes$kME.MEpurple), ]
Purple.genes
Central.genes <- Purple.genes[1:10]
Central.genes <- Purple.genes[1:10, ]
Central.genes
ASDtbl <- read.table("supDataASDgenes.txt", header = TRUE, sep="\t", stringsAsFactors = FALSE)
genesCortex <- na.omit(unique(fData(bsd.cortex.norm)$SYMBOL))
# Get autism susceptibility genes that are also present in the cortex data (using %in% to compare lists)
genesASD <- ASDtbl$Gene[ASDtbl$Gene %in% genesCortex]
m <- length(genesASD) # number of ASD genes
n <- length(genesCortex) - m # number of non-ASD genes
# Calculate the probability of modules being enriched with austism susceptibility genes
p.value <- apply(kME, 2, function(kMEcolumn){
# Map probes to gene names, calculating per gene the mean of the probes' module membership value
gene.kME <- tapply(kMEcolumn, fData(bsd.cortex.norm)$SYMBOL[, drop = TRUE], mean)
# How many genes in module, above the cutoff score
k <- sum(gene.kME > 0.7)
# How many ASD genes in module, above the cutoff score
kASD <- sum(gene.kME[genesASD] > 0.7)
# The probability of having that many ASD genes in the module by chance (hyper-geometric test)
return(1 - phyper(kASD - 1, m, n, k))
})
p.value <- p.value[order(p.value)] # Order by significance
# Adjust pvalues for multiple testing
p.adj <- p.adjust(p.value, method="fdr")
p.adj
p.value
str(modules)
modules$MEs["MEmagenta"]
# Compute correlation between all genes and all module eigengenes
kME <- cor(exp, modules$MEs)
kME
intra_cor <- c()
for (m in colnames(kME)) {
if (m != "MEgrey") {
intra_cor <- c(intra_cor, kME[paste("ME", modules$colors, sep = "") == m, m])
}
}
hist(intra_cor, xlim = c(-1,1), breaks = seq(-1,1,0.1),
main = "Correlations with module eigengene (within module correlation)",
xlab = "Correlation")
df$hasAutism
?blockwiseModules
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("pathview")
knitr::opts_chunk$set(echo = TRUE)
library(pathview)
data(gse16873.d)
data(gse16873.d)
knitr::opts_chunk$set(echo = TRUE)
library(pathview)
data(gse16873.d)
s data(gse16873.d)
s <- data(gse16873.d)
library(pathview)
data(gse16873.d)
library(pathview)
data(gse16873.d)
data(gse16873.d)
pv.out <- pathview(gene.data = gse16873.d[, 1], pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
pv.out <- pathview(gene.data = gse16873.d[, :], pathway.id = "04110",
pv.out <- pathview(gene.data = gse16873.d[, ], pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
head(pv.out$plot.data.gene)
?pathview
pv.out <- pathview(gene.data = gse16873.d[, ], node.sum = "mean", pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
head(pv.out$plot.data.gene)
pv.out <- pathview(gene.data = gse16873.d[, ], pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
head(pv.out$plot.data.gene)
head(pw.mean$plot.data.gene)
pw.mean <- pathview(gene.data = gse16873.d[, ], node.sum = "mean", pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
head(pw.mean$plot.data.gene)
pw.mean$plot.data.cpd
pw.mean$plot.data.gene
pw.mean <- pathview(gene.data = gse16873.d[,1 ], node.sum = "mean", pathway.id = "04110",
species = "hsa", out.suffix = "gse16873")
head(pw.mean$plot.data.gene)
sim.cpd.data = sim.mol.data(mol.type = "cpd", nmol = 3000)
pathview(gene.data = gse16873.d[, 1], cpd.data = sim.cpd.data,
pathway.id = "00640", species = "hsa", out.suffix = "gse16873.mbl")
load("~/R/BIN/BIN315/voineagu_DEA_rnaseq.RData")
BiocManager::install("DESeq2")
load("~/R/BIN/BIN315/voineagu_DEA_rnaseq.RData")
setwd("~/R/BIN/BIN315")
load("~/R/BIN/BIN315/voineagu_DEA_rnaseq.RData")
load("~/R/BIN/BIN315/voineagu_DEA_rnaseq.RData")
load("~/R/BIN/BIN315/voineagu_normalized_rnaseq.RData")
View(dds)
View(res.sig)
exprs(res.sig)
knitr::opts_chunk$set(echo = TRUE)
library(DESeq2)
df <- exprs(res.sig)
exprs(res.sig)
```
exprs(res.sig)
exprs(dds)
knitr::opts_chunk$set(echo = TRUE)
df <- exprs(res.sig)
res.sig
res.sig$log2FoldChange
df <- res.sig$log2FoldChange
df
df <- data.frame(res.sig$log2FoldChange)
df
load("M12.gene.symbols.txt")
M12 <- load("M12.gene.symbols.txt")
M12.gene.symbols <- read.csv("~/R/BIN/BIN315/M12.gene.symbols.txt", sep="")
View(M12.gene.symbols)
rownames(df) <- M12.gene.symbols
M12.gene.symbols
rownames(df) <- M12.gene.symbols$x
df <- data.frame(res.sig$log2FoldChange)
df
res.sig
rownames(df) <- rownames(res.sig)
pathview(gene.data = df[,1 ], node.sum = "mean", gene.idtype = "ENSEMBL", pathway.id = "04110",
species = "hsa", out.suffix = "test")
library(pathview)
pathview(gene.data = df[,1 ], node.sum = "mean", gene.idtype = "ENSEMBL", pathway.id = "04110",
species = "hsa", out.suffix = "test")
pathview(gene.data = df[,1 ], node.sum = "mean", gene.idtype = "ENSEMBL",species = "hsa", out.suffix = "test")
dds
exprs(dds)
rownames(res.sig)
pathview(gene.data = df[,1 ], node.sum = "mean", gene.idtype = "ENSEMBL")
pw.df <- pathview(gene.data = df[,1 ], node.sum = "mean", gene.idtype = "ENSEMBL")
?pathway
?pathview
pw.df <- pathview(gene.data = df[,1 ], node.sum = "mean", gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa")
dds
pw.df <- pathview(gene.data = df[, ], node.sum = "mean", gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa")
version(pathview)
pw.df <- pathview(gene.data = df[, ], node.sum = "mean", gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", out.suffix = "test")
pw.df <- pathview(gene.data = df[, ], node.sum = "mean", gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", out.suffix = "test", plot.data.gene)
pw.df <- pathview(gene.data = df[, ], gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", out.suffix = "test")
pw.df <- pathview(gene.data = df[, ], gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", out.suffix = "test", node.sum = "mean")
pw.df <- pathview(gene.data = df[, ], gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", out.suffix = "test")
gene.idtype.list
pw.df <- pathview(gene.data = df[, ], gene.idtype = "ENSEMBLTRANS", pathway.id = "04721", species = "hsa", node.sum = "mean", out.suffix = "test")
pw.df <- pathview(gene.data = df[, ], gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", out.suffix = "test")
df
gse16873.d
pw.df <- pathview(gene.data = df[, ], gene.idtype = "ENSEMBL", pathway.id = "04261", species = "hsa", node.sum = "mean", out.suffix = "test")
pw.df <- pathview(gene.data = df[, 1], gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", out.suffix = "test")
pathview(gene.data = df)
pw.df <- pathview(gene.data = df, gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", out.suffix = "test")
plot(pd.df)
```{r}
![](hsa04721.png)
pw.df <- pathview(gene.data = df, gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", limit = list(gene=2) out.suffix = "test")
pw.df <- pathview(gene.data = df, gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", limit = list(gene=2) out.suffix = "test")
pw.df <- pathview(gene.data = df, gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", limits = list(gene=2), out.suffix = "test")
res.sig$pvalue,
res.sig$pvalue
pdf <- data.frame(sign(-log10(res.sig$pvalue)))
pdf
-log10(res.sig$padj)
res.sig$pvalue
-log(res.sig$pvalue)
pdf <- data.frame(-log10(res.sig$pvalue))
pdf <- sign(pdf)
pdf
pdf <- data.frame(-log10(res.sig$pvalue))
?sign
pdf <- data.frame(-log10(res.sig$pvalue))
pdf
pdf <- data.frame(-log10(res.sig$padj))
pdf
pdf <- data.frame(-log10(res.sig$pvalue))
rownames(pdf) <- rownames(res.sig)
pw.pdf <- pathview(gene.data = df, gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", limits = list(gene=2), out.suffix = "pvalue")
![](hsa04721.pvalue.png)
pw.pdf <- pathview(gene.data = df, gene.idtype = "ENSEMBL", pathway.id = "04721", species = "hsa", node.sum = "mean", limits = list(gene=5), out.suffix = "pvalue")
pw.pdf <- pathview(gene.data = df, gene.idtype = "ENSEMBL", pathway.id = "04261", species = "hsa", node.sum = "mean", limits = list(gene=5), out.suffix = "pvalue")
---
title: "Data integration"
author: "Trude Almestrand"
date: "26 10 2020"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Data integration
## Questions
*1. A biomedical researcher gives you both metabolomics data and clinical data (weight, cholesterol, blood pressure, etc) for a number of individuals. You also know which of them that are sick and healthy. You want to find out what determines that a patient is sick or healthy. How would you analyze the data? Write approximately 250 words.*
First of all I would sort the data into two categories: sick and healthy. By assigning the healthy as the reference data any statistical significant deviation from the set of data points will categorize an individual as sick. The features would be the different metabolomics and clinical data. Seeing as this might be a lot of features, it would be beneficial to find a way to reduce all the features to avoid overfitting and redundancy. Would use a supervised method seeing as we assume a variance between the clinical and metabolomic data, and we already know the data-structure.
the model would be: Individuals health = f(metabolomics, clinical) using the sick/healthy data as training data. We may not find a lot of explanation of the variance using PLS so we can then use another supervised machine learning method.
Approach of concatenation is also a very attractive approach, or a combination to check for overfitting.
Contatenate the two datasets by comparing metabolite data in sick to the one in healthy and the clinical data in sick to the one in healthy. Seeing as we might not deal with too many features. Could get a model of: if bloodpressure > given value and metabolite > 0 THEN sick. Could also use factor analysis using loadings to find which metabolites and component is descriptive. Or another supervised method. Could ideally use all of these to test the model against each other and see if they give the same answer (or not, if not may show an error in PLS for instance)
*2. A famous plant biologist study wood formation in trees. He has done a GWAS study in a population of 1000 trees and identified a number of SNPs associated with increased biomass production. He has also  measured gene expression in the population, and identified eQTLs; many of which coincide with GWAS SNPs. However, none of these SNPs are located inside genes or even near genes. The biologist now comes to you.  He want to construct a regulatory network to better understand biomass production in trees. What experiments would you propose and how would you analyse the data? Write approximately 500 words.*
The SNPs are most likely located near a transcription factor site or a source of histone modification. This means that it indirectly regulates the gene expression for the biomass production. An SNP near a histone binding site may lead to a different packing of DNA making it either more prone to transcription or less so. If a change occurs near a TF binding site it may compromise the binding meaning less transcription of a given gene into a protein. Using Chip seq (or ATAC-seq) you can check where a transcription factor binds in the genome, as well as histone modification. Seeing as the plant biologist already has gene expression in the population he can find co-expression modules using the expression data to cluster genes together. This makes the analysis easier and gives an idea of how if one TF that is associated with a gene changes, the module does as well. With this we can identify potential regulators for the modules as well.
After a co-expression network has been formed (for instance using WGCNA) we need to check for over-represented binding sites using information from the ChIP-Seq data. We want to find the probability of getting an overlap between a set of genes in a given module and a set of genes with binding sites for a specific TF. This can be done using a hypergeometric test. The could would be something like: for every module, for every TF in the module, check if the TF is over-represented in the module using the hypergeometric test and store the results for each test (Gillard, 2020). Some tests may have a type I error so it would be beneficial to reduce the number of false positives using a p.adjust function as well. The nodes in the finishes analysis would be the modules and the links would be the link between TF and gene. Edges would here be the genes present in the overlap. Seeing as we have sorted for cluster of genes using WGCNA we can then see if TF affects some genes in the different clusters. This would be the significant genes with a given TF in each module. This data could also
Sourced:
Gillard, Grønvold & Mähler, *BIN315: Lab 8 - Omics data integration and biological knowledge*, 2020 from BIN315 canvas.
## Computer lab
#### Integrating data from several sources can reveal interesting details. In this lab we will look at gene expression (RNA-Seq) and chromatin immunoprecipitation, followed by sequencing (ChIP-Seq) data from the worm Caenorhabditis elegans. The goal is to find co-expression modules using the expression data, and then see if we can identify potential regulators for these moduels by finding enrichment of transcription factor (TF) binding sites in the modules.
```{r}
library(WGCNA)
allowWGCNAThreads()
worm_gene <- read.delim2("~/R/BIN/BIN315/worm_gene.txt", header=TRUE, dec = ",")
# I know I can use subset, but needed some repetition on column/row selection as well
worm_gene.mat <- worm_gene[c(11:121)]
row.names(worm_gene.mat) <- worm_gene[,1]
worm_gene.mat <- worm_gene.mat[2:20378,]
# Get modules of gene clusters like we did in Lab 6
modules <- blockwiseModules(datExpr = t(worm_gene.mat), numericLabels = TRUE, dec = ",")
# Get all the (unique) module labels
module.labels <- unique(modules$colors)
gene.tf <- read.delim2(file = "ce_gene_tf.txt")
```
*How many modules do you find?*
99 modules
*How many genes are in each module (see code from lab 6)?*
111 genes per module (str(modules) or str(modules@MEs) shows the answer)
It is time to implement this for our network modules and TF binding information. To summarize the code: for every module, for every TF in the module, check if the TF is over-represented in the module using the hypergeometric test and store the results for each test.
```{r}
# This will be the data frame where we will store all the results (starts off empty/NULL)
enrichment_res <- NULL
# Get the total number of genes in the data matrix (total number of balls)
n.genes <- nrow(worm_gene.mat)
# For each module...
for (module in module.labels) {
# Get genes in the module
module.genes <- worm_gene$Gene[modules$colors == module]
# Get number of genes in the module (the number of balls drawn)
k <- length(module.genes)
# For each TF...
for (tf in unique(gene.tf$tf)) {
# Get number of unique genes that have this TF (the number of white balls)
m <- length(unique(gene.tf$gene[gene.tf$tf == tf]))
# Get the number of genes that don't have the TF (the number of black balls)
n <- n.genes - m
# Get number of unique genes in the cluster that have this TF (the number of white balls drawn)
q <- length(unique(gene.tf$gene[gene.tf$tf == tf & gene.tf$gene %in% module.genes]))
# Hypergeometric test checking for over-representation of TF binding
p <- phyper(q, m, n, k, lower.tail = FALSE)
# Add the test results to the data frame
enrichment_res = rbind(enrichment_res, data.frame(module = module, tf = tf, q, m, n, k, p))
}
}
```
In the test above, we tested every single TF for each module. That is a total of 86 tests per module, and we would expect some tests to be significant purely by chance. To reduce the number of false positives, we will have to adjust our P-values for multiple testing. We will do the adjustment for each module individually using the p.adjust function:
```{r}
# Add an empty column 'padj' to the results data frame
enrichment_res$padj <- NA
# For each module...
for (module in module.labels) {
# Adjust the p-values using the p.adjust function (using the false discovery rate method, FDR)
padj <- p.adjust(enrichment_res$p[enrichment_res$module == module], method = "fdr")
# Add it to the padj column
enrichment_res$padj[enrichment_res$module == module] <- padj
}
# Finally, we can sort the results based on the adjusted p-values
enrichment_res <- enrichment_res[order(enrichment_res$padj), ]
enrichment_res[1:10,]
```
So now we have all results in the data frame enrichment_res with the network module color, the TF, the input for the hypergeometric test and the p-values and adjusted p-values.
*How many clusters have at least one over-represented transcription factor binding site?*
Apparently 10 clusters have at least one over-represented transcription factor binding site.
```{r}
# There are many ways to this, and here is one way:
# Sum the number of TRUE values (at least one TF enriched) from the module results
sum(sapply(module.labels, function(module) { # Apply for each module label a function
# Taking a module label, sum the number of TRUE values (number of TFs with padj < 0.05) for that module
sum(enrichment_res$padj[enrichment_res$module == module] < 0.05) >= 1 # Test if the number of enriched TFs is 1 or more for that module
}))
```
*Explain how to interpret the results in enrichment_res.*
The results in enrichment res shows where a transcription factor is overrepresented (significant) according to a hypergeometric test of data in a given module.
*How can the results in enrichment_res be represented as a regulatory networks? What would be the nodes? What would the edges/links represent?*
The nodes would be the modules and the links would be the link between TF and gene. Edges would here be the genes present in the overlap. Seeing as we have sorted for cluster of genes using WGCNA we can then see if TF affects some genes in the different clusters. This would be the significant genes with a given TF in each module.
load("~/R/BIN/BIN315/TCGA.RData")
View(expr)
nrow(expr)
